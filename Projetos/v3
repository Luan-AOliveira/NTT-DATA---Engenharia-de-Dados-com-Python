import textwrap
from datetime import datetime
from abc import ABC, abstractmethod

class Cliente:
    def __init__(self, nome, cpf, endereco):
        self.nome = nome
        self.cpf = cpf
        self.endereco = endereco
        self.contas = []

    def realizar_transacao(self, conta, transacao):
        if len(conta.historico.transacoes_do_dia()) >= 2:
            print("\n@@@ Limite de transações diárias atingido! @@@")
        else:
            transacao.registrar(conta)

    def adicionar_conta(self, conta):
        self.contas.append(conta)

class Conta:
    def __init__(self, numero, cliente, agencia="0001"):
        self.numero = numero
        self.agencia = agencia
        self.cliente = cliente
        self.saldo = 0
        self.historico = Historico()

    def sacar(self, valor):
        if valor > self.saldo:
            print("\n@@@ Saldo insuficiente! @@@")
            return False
        self.saldo -= valor
        print("\n=== Saque realizado com sucesso! ===")
        return True

    def depositar(self, valor):
        if valor <= 0:
            print("\n@@@ Valor inválido! @@@")
            return False
        self.saldo += valor
        print("\n=== Depósito realizado com sucesso! ===")
        return True

class ContaCorrente(Conta):
    def __init__(self, numero, cliente, limite=500, limite_saques=3):
        super().__init__(numero, cliente)
        self.limite = limite
        self.limite_saques = limite_saques

    def sacar(self, valor):
        saques_hoje = len([t for t in self.historico.transacoes if t["tipo"] == "Saque"])
        if saques_hoje >= self.limite_saques:
            print("\n@@@ Limite de saques excedido! @@@")
            return False
        if valor > self.limite:
            print("\n@@@ Valor do saque excede o limite! @@@")
            return False
        return super().sacar(valor)

class Historico:
    def __init__(self):
        self.transacoes = []

    def adicionar_transacao(self, tipo, valor):
        self.transacoes.append({
            "tipo": tipo,
            "valor": valor,
            "data": datetime.now().strftime("%d-%m-%Y %H:%M:%S")
        })

    def transacoes_do_dia(self):
        hoje = datetime.now().date()
        return [t for t in self.transacoes if datetime.strptime(t["data"], "%d-%m-%Y %H:%M:%S").date() == hoje]

class Transacao(ABC):
    def __init__(self, valor):
        self.valor = valor

    @abstractmethod
    def registrar(self, conta):
        pass

class Saque(Transacao):
    def registrar(self, conta):
        if conta.sacar(self.valor):
            conta.historico.adicionar_transacao("Saque", self.valor)

class Deposito(Transacao):
    def registrar(self, conta):
        if conta.depositar(self.valor):
            conta.historico.adicionar_transacao("Depósito", self.valor)

def menu():
    return input(textwrap.dedent("""
        ================ MENU ================
        [d] Depositar
        [s] Sacar
        [e] Extrato
        [nc] Nova conta
        [nu] Novo usuário
        [q] Sair
        => """))

def encontrar_cliente(cpf, clientes):
    return next((c for c in clientes if c.cpf == cpf), None)

def recuperar_conta(cliente):
    return cliente.contas[0] if cliente.contas else None

def depositar(clientes):
    cpf = input("Informe o CPF: ")
    cliente = encontrar_cliente(cpf, clientes)
    if not cliente:
        print("\n@@@ Cliente não encontrado! @@@")
        return
    valor = float(input("Informe o valor do depósito: "))
    conta = recuperar_conta(cliente)
    Deposito(valor).registrar(conta)

def sacar(clientes):
    cpf = input("Informe o CPF: ")
    cliente = encontrar_cliente(cpf, clientes)
    if not cliente:
        print("\n@@@ Cliente não encontrado! @@@")
        return
    valor = float(input("Informe o valor do saque: "))
    conta = recuperar_conta(cliente)
    Saque(valor).registrar(conta)

def exibir_extrato(clientes):
    cpf = input("Informe o CPF: ")
    cliente = encontrar_cliente(cpf, clientes)
    if not cliente:
        print("\n@@@ Cliente não encontrado! @@@")
        return
    conta = recuperar_conta(cliente)
    print("\n=== EXTRATO ===")
    for transacao in conta.historico.transacoes:
        print(f"{transacao['data']} - {transacao['tipo']} - R$ {transacao['valor']:.2f}")
    print(f"Saldo: R$ {conta.saldo:.2f}")

def criar_cliente(clientes):
    cpf = input("Informe o CPF: ")
    if encontrar_cliente(cpf, clientes):
        print("\n@@@ Cliente já cadastrado! @@@")
        return
    nome = input("Informe o nome: ")
    endereco = input("Informe o endereço: ")
    clientes.append(Cliente(nome, cpf, endereco))
    print("\n=== Cliente criado com sucesso! ===")

def criar_conta(clientes, contas):
    cpf = input("Informe o CPF do cliente: ")
    cliente = encontrar_cliente(cpf, clientes)
    
    if not cliente:
        print("\n@@@ Cliente não encontrado! @@@")
        return
    
    numero = len(contas) + 1  # Gerar número da conta baseado no tamanho da lista de contas
    conta = ContaCorrente(numero, cliente)  # Criar nova conta corrente
    
    cliente.adicionar_conta(conta)  # Adicionar conta ao cliente
    contas.append(conta)  # Adicionar a conta na lista geral de contas
    
    print("\n=== Conta criada com sucesso! ===")


def main():
    clientes = []
    contas = []
    while True:
        opcao = menu()
        if opcao == 'd':
            depositar(clientes)
        elif opcao == 's':
            sacar(clientes)
        elif opcao == 'e':
            exibir_extrato(clientes)
        elif opcao == 'nu':
            criar_cliente(clientes)
        elif opcao == 'nc':
            criar_conta(clientes, contas)
        elif opcao == 'q':
            break
        else:
            print("\n@@@ Opção inválida! @@@")

main()
